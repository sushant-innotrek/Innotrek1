1
00:00:03,020 --> 00:00:05,720
 हाय, मैं कैरी ऐनी हूं, और क्रैशकोर्स कंप्यूटर साइंस में आपका स्वागत है! 

2
00:00:05,720 --> 00:00:09,980
 इसलिए हमने इस श्रृंखला में क्रमबद्ध करने और संख्याओं की सूची को क्रमबद्ध करने के लिए अक्सर कोड के बारे में बहुत कुछ बोला है 

3
00:00:09,980 --> 00:00:13,860
 केवल दस लाइनें लंबी हो सकती हैं, जो एक प्रोग्रामर लिखने के लिए काफी आसान है। 

4
00:00:13,860 --> 00:00:16,910
 इसके अलावा, यह इतना छोटा है कि आपको किसी भी विशेष उपकरण की आवश्यकता नहीं है - आप इसे कर सकते हैं 

5
00:00:16,910 --> 00:00:17,910
 नोटपैड में 

6
00:00:17,910 --> 00:00:18,910
 वास्तव में! 

7
00:00:18,910 --> 00:00:22,720
 लेकिन, एक सॉर्टिंग एल्गोरिदम एक कार्यक्रम नहीं है; यह शायद बहुत अधिक का एक छोटा सा हिस्सा है 

8
00:00:22,720 --> 00:00:23,890
 बड़ा कार्यक्रम 

9
00:00:23,890 --> 00:00:27,439
 उदाहरण के लिए, माइक्रोसॉफ्ट ऑफिस में कोड की लगभग 40 लाख लाइनें हैं। 

10
00:00:27,439 --> 00:00:28,720
 40 मिलियन! 

11
00:00:28,720 --> 00:00:32,049
 किसी भी व्यक्ति को पता लगाने और लिखने के लिए यह बहुत बड़ा तरीका है! 

12
00:00:32,049 --> 00:00:36,250
 इस तरह के बड़े कार्यक्रम बनाने के लिए, प्रोग्रामर उपकरण और प्रथाओं का एक सेट उपयोग करते हैं। 

13
00:00:36,250 --> 00:00:40,300
 एक साथ लिया गया, ये सॉफ्टवेयर इंजीनियरिंग का अनुशासन है - एक शब्द बनाया गया 

14
00:00:40,300 --> 00:00:44,510
 इंजीनियर मार्गरेट हैमिल्टन द्वारा, जिन्होंने नासा को अपोलो के दौरान गंभीर समस्याओं को रोकने में मदद की 

15
00:00:44,510 --> 00:00:45,610
 चंद्रमा के मिशन। 

16
00:00:45,610 --> 00:00:49,149
 उसने एक बार इसे इस तरह समझाया: "यह एक रूट नहर की तरह है: आप तक इंतजार कर रहे थे 

17
00:00:49,149 --> 00:00:51,820
 अंत, [लेकिन] ऐसी चीजें हैं जो आप पहले कर सकते थे। 

18
00:00:51,820 --> 00:00:55,220
 यह निवारक स्वास्थ्य देखभाल की तरह है, लेकिन यह निवारक सॉफ्टवेयर है। " 

19
00:00:55,220 --> 00:01:04,340
 परिचय 

20
00:01:04,400 --> 00:01:08,420
 जैसा कि मैंने एपिसोड 12 में उल्लेख किया है, छोटे कार्यों में बड़े कार्यक्रमों को तोड़ने से कई लोग अनुमति देते हैं 

21
00:01:08,420 --> 00:01:10,280
 लोगों को एक साथ काम करने के लिए। 

22
00:01:10,280 --> 00:01:14,040
 उन्हें पूरी चीज के बारे में चिंता करने की ज़रूरत नहीं है, बस वे जिस काम पर काम कर रहे हैं। 

23
00:01:14,100 --> 00:01:18,040
 इसलिए, यदि आपको एक प्रकार के एल्गोरिदम लिखने के लिए काम सौंपा गया है, तो आपको केवल यह सुनिश्चित करने की आवश्यकता है कि यह टाइप हो 

24
00:01:18,060 --> 00:01:19,380
 ठीक से और कुशलता से। 

25
00:01:19,389 --> 00:01:22,429
 हालांकि, यहां तक ​​कि फ़ंक्शन में कोड पैक करना पर्याप्त नहीं है। 

26
00:01:22,429 --> 00:01:25,380
 माइक्रोसॉफ्ट ऑफिस में शायद उनमें से सैकड़ों हजार शामिल हैं। 

27
00:01:25,380 --> 00:01:29,149
 यह कोड की 40 मिलियन लाइनों से निपटने से बेहतर है, लेकिन यह अभी भी बहुत अधिक है 

28
00:01:29,149 --> 00:01:31,229
 एक व्यक्ति या टीम के प्रबंधन के लिए "चीजें"। 

29
00:01:31,229 --> 00:01:35,570
 समाधान पदानुक्रमों में कार्यों को पैकेज करना है, एक साथ संबंधित कोड खींचना 

30
00:01:35,570 --> 00:01:36,740
 "वस्तुओं" में। 

31
00:01:36,740 --> 00:01:40,719
 उदाहरण के लिए, कार के सॉफ़्टवेयर में क्रूज़ नियंत्रण से संबंधित कई कार्य हो सकते हैं, जैसे 

32
00:01:40,719 --> 00:01:44,530
 गति की गति, गति को ऊपर या नीचे, और क्रूज नियंत्रण को पूरी तरह से रोकना। 

33
00:01:44,530 --> 00:01:48,459
 चूंकि वे सभी संबंधित हैं, हम उन्हें एक एकीकृत क्रूज नियंत्रण वस्तु में लपेट सकते हैं। 

34
00:01:48,459 --> 00:01:52,119
 लेकिन, हमें वहां रुकना नहीं है, क्रूज कंट्रोल इंजन का सिर्फ एक हिस्सा है 

35
00:01:52,119 --> 00:01:53,119
 सॉफ्टवेयर। 

36
00:01:53,119 --> 00:01:56,979
 स्पार्क प्लग इग्निशन, ईंधन पंप, और नियंत्रित करने वाले कार्यों के सेट भी हो सकते हैं 

37
00:01:56,979 --> 00:01:58,090
 रेडिएटर। 

38
00:01:58,090 --> 00:02:01,810
 इसलिए हम एक "पैरेंट" इंजन ऑब्जेक्ट बना सकते हैं जिसमें इन सभी "बच्चों" 

39
00:02:01,810 --> 00:02:02,420
 वस्तुओं। 

40
00:02:02,420 --> 00:02:05,860
 बच्चों * वस्तुओं * के अलावा, इंजन के अपने * अपने * कार्यों हो सकता है। 

41
00:02:05,900 --> 00:02:08,419
 उदाहरण के लिए, आप इसे रोकने और इसे शुरू करने में सक्षम होना चाहते हैं। 

42
00:02:08,419 --> 00:02:12,150
 इसमें अपने चर भी होंगे, जैसे कार ने कितनी मील की यात्रा की है। 

43
00:02:12,150 --> 00:02:15,860
 सामान्य रूप से, वस्तुओं में अन्य ऑब्जेक्ट्स, फ़ंक्शन और वेरिएबल हो सकते हैं। 

44
00:02:15,860 --> 00:02:18,770
 और निश्चित रूप से, इंजन कार ऑब्जेक्ट का सिर्फ एक हिस्सा है। 

45
00:02:18,770 --> 00:02:21,780
 ट्रांसमिशन, पहियों, दरवाजे, खिड़कियां, और इसी तरह भी है। 

46
00:02:21,780 --> 00:02:25,849
 अब, एक प्रोग्रामर के रूप में, अगर मैं क्रूज नियंत्रण सेट करना चाहता हूं, तो मैं ऑब्जेक्ट को नेविगेट करता हूं 

47
00:02:25,849 --> 00:02:29,819
 पदानुक्रम, बाहरी वस्तुओं से अधिक से अधिक गहराई से घोंसले वाले। 

48
00:02:29,819 --> 00:02:33,940
 आखिरकार, मैं उस फ़ंक्शन तक पहुंचता हूं जिसे मैं ट्रिगर करना चाहता हूं: "कार, फिर इंजन, फिर क्रूज़ 

49
00:02:33,940 --> 00:02:36,340
 नियंत्रण, फिर क्रूज गति 55 पर सेट करें "। 

50
00:02:36,340 --> 00:02:39,940
 प्रोग्रामिंग भाषाएं अक्सर यहां दिखाए गए वाक्यविन्यास के बराबर कुछ का उपयोग करती हैं। 

51
00:02:39,940 --> 00:02:44,560
 नेस्टेड ऑब्जेक्ट्स में कार्यात्मक इकाइयों को पैक करने का विचार ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग कहा जाता है। 

52
00:02:44,569 --> 00:02:49,120
 यह बहुत ही समान है कि हमने सभी श्रृंखलाओं को लंबे समय तक किया है: encapsulating द्वारा जटिलता छुपाएं 

53
00:02:49,120 --> 00:02:52,020
 उच्च-आदेश घटकों में निम्न-स्तर का विवरण। 

54
00:02:52,020 --> 00:02:56,040
 इससे पहले कि हमने ट्रांजिस्टर सर्किट जैसे चीजों को उच्च स्तरीय बूलियन गेट्स में पैक किया। 

55
00:02:56,080 --> 00:02:57,970
 अब हम सॉफ्टवेयर के साथ एक ही काम कर रहे हैं। 

56
00:02:57,970 --> 00:03:07,820
 फिर भी, यह एक नए स्तर के अमूर्तता को आगे बढ़ाने का एक तरीका है! 

57
00:03:07,820 --> 00:03:11,800
 एक कार के सॉफ्टवेयर की तरह, एक बड़ा कार्यक्रम तोड़ना, कार्यात्मक इकाइयों में सही है 

58
00:03:11,829 --> 00:03:12,860
 टीमों के लिए। 

59
00:03:12,870 --> 00:03:16,870
 क्रूज कंट्रोल सिस्टम और एक प्रोग्रामर के लिए एक टीम जिम्मेदार हो सकती है 

60
00:03:16,870 --> 00:03:19,270
 वह टीम कुछ हद तक काम करती है। 

61
00:03:19,270 --> 00:03:22,189
 यह गगनचुंबी इमारतों की तरह, कितनी बड़ी, भौतिक चीजें बनाई गई है। 

62
00:03:22,189 --> 00:03:26,810
 आपके पास बिजली चलने वाले बिजली, प्लंबर फिटिंग पाइप, वेल्डर वेल्डिंग, पेंटर्स होंगे 

63
00:03:26,810 --> 00:03:29,879
 पेंटिंग, और सैकड़ों अन्य लोग पूरे पतवार पर चिल्ला रहे हैं। 

64
00:03:29,879 --> 00:03:34,060
 वे एक साथ विभिन्न भागों पर एक साथ काम करते हैं, अपने विभिन्न कौशल का लाभ उठाते हैं। 

65
00:03:34,060 --> 00:03:36,620
 एक दिन तक, आपको पूरी तरह से काम करने वाली इमारत मिल गई है! 

66
00:03:36,620 --> 00:03:41,060
 लेकिन, हमारे क्रूज नियंत्रण उदाहरण पर लौट रहे हैं ... इसके कोड को कार्यों का उपयोग करना होगा 

67
00:03:41,060 --> 00:03:45,269
 इंजन के सॉफ़्टवेयर के अन्य हिस्सों में, आप जानते हैं, कार को लगातार गति से रखें। 

68
00:03:45,269 --> 00:03:48,060
 वह कोड क्रूज़ कंट्रोल टीम की ज़िम्मेदारी का हिस्सा नहीं है। 

69
00:03:48,060 --> 00:03:49,810
 यह एक और टीम का कोड है। 

70
00:03:49,810 --> 00:03:53,400
 चूंकि क्रूज कंट्रोल टीम ने यह नहीं लिखा था, इसलिए उन्हें अच्छे दस्तावेज़ीकरण की आवश्यकता होगी 

71
00:03:53,400 --> 00:03:57,549
 कोड में प्रत्येक कार्य क्या करता है, और एक अच्छी तरह से परिभाषित अनुप्रयोग प्रोग्रामिंग के बारे में 

72
00:03:57,549 --> 00:03:59,829
 इंटरफेस - या कम के लिए एपीआई। 

73
00:03:59,829 --> 00:04:04,359
 आप एपीआई के बारे में सोच सकते हैं कि प्रोग्रामर सहयोग करने वाले विभिन्न हिस्सों में बातचीत करते हैं 

74
00:04:04,360 --> 00:04:04,980
 कोड का 

75
00:04:04,980 --> 00:04:08,960
 उदाहरण के लिए, IgnitionControl ऑब्जेक्ट में, RPM सेट करने के लिए फ़ंक्शन हो सकते हैं 

76
00:04:08,969 --> 00:04:12,840
 इंजन, स्पार्क प्लग वोल्टेज की जांच करें, साथ ही साथ व्यक्तिगत स्पार्क प्लग को भी आग लगें। 

77
00:04:12,840 --> 00:04:17,089
 मोटर के आरपीएम को सेट करने में सक्षम होने के नाते वास्तव में उपयोगी है, क्रूज कंट्रोल टीम जा रही है 

78
00:04:17,089 --> 00:04:18,429
 उस समारोह को कॉल करने की आवश्यकता है। 

79
00:04:18,430 --> 00:04:21,488
 लेकिन, वे इस बारे में ज्यादा नहीं जानते कि इग्निशन सिस्टम कैसे काम करता है। 

80
00:04:21,488 --> 00:04:25,569
 व्यक्तिगत स्पार्क प्लग को आग लगाने वाले कार्यों को कॉल करने का अच्छा विचार नहीं है। 

81
00:04:25,569 --> 00:04:26,780
 या इंजन विस्फोट हो सकता है! 

82
00:04:26,780 --> 00:04:27,780
 शायद। 

83
00:04:27,780 --> 00:04:31,340
 एपीआई सही लोगों को सही कार्यों और डेटा तक पहुंचने की अनुमति देता है। 

84
00:04:31,340 --> 00:04:34,940
 ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग भाषाएं आपको यह बताकर ऐसा करती हैं कि फ़ंक्शन हैं या नहीं 

85
00:04:34,949 --> 00:04:36,420
 सार्वजनिक या निजी। 

86
00:04:36,430 --> 00:04:40,120
 यदि किसी फ़ंक्शन को "निजी" के रूप में चिह्नित किया गया है, तो इसका मतलब केवल उस ऑब्जेक्ट के अंदर कार्य करता है 

87
00:04:40,120 --> 00:04:41,120
 इसे कॉल कर सकते हैं 

88
00:04:41,120 --> 00:04:45,750
 तो, इस उदाहरण में, IgnitionControl के अंदर केवल अन्य कार्य, setRPM की तरह 

89
00:04:45,750 --> 00:04:47,880
 समारोह, स्पार्कप्लग आग कर सकते हैं। 

90
00:04:47,880 --> 00:04:52,870
 दूसरी ओर, क्योंकि setRPM फ़ंक्शन को सार्वजनिक के रूप में चिह्नित किया जाता है, अन्य ऑब्जेक्ट्स कॉल कर सकते हैं 

91
00:04:52,870 --> 00:04:54,280
 यह, क्रूज नियंत्रण की तरह। 

92
00:04:54,280 --> 00:04:58,630
 जटिलता को छिपाने की क्षमता, और चुनिंदा रूप से इसे प्रकट करने, ऑब्जेक्ट ओरिएंटेड का सार है 

93
00:04:58,630 --> 00:05:03,280
 प्रोग्रामिंग, और यह बड़े और जटिल कार्यक्रमों के निर्माण से निपटने के लिए एक शक्तिशाली और लोकप्रिय तरीका है। 

94
00:05:03,280 --> 00:05:07,220
 आपके कंप्यूटर पर सॉफ़्टवेयर के हर टुकड़े, या आपके कंसोल पर चल रहे गेम, 

95
00:05:07,229 --> 00:05:12,759
 ऑब्जेक्ट ओरिएंटेड प्रोग्रामिंग भाषा का उपयोग करके बनाया गया था, जैसे सी ++, सी # या ऑब्जेक्टिव-सी। अन्य 

96
00:05:12,759 --> 00:05:15,569
 लोकप्रिय "ओओ" भाषाओं में आपने पाइथन और जावा के बारे में सुना होगा। 

97
00:05:15,569 --> 00:05:19,150
 कोड को याद रखना महत्वपूर्ण है, संकलित होने से पहले, बस पाठ है। 

98
00:05:19,150 --> 00:05:23,300
 जैसा कि मैंने पहले उल्लेख किया था, आप नोटपैड या किसी पुराने वर्ड प्रोसेसर में कोड लिख सकते हैं। 

99
00:05:23,300 --> 00:05:24,300
 कुछ लोग करते हैं। 

100
00:05:24,300 --> 00:05:28,229
 लेकिन आम तौर पर, आज के सॉफ्टवेयर डेवलपर्स लिखने के लिए विशेष उद्देश्य के अनुप्रयोगों का उपयोग करते हैं 

101
00:05:28,229 --> 00:05:33,080
 कार्यक्रम, जो लेखन, आयोजन, संकलन और लेखन के लिए कई उपयोगी टूल एकीकृत करते हैं 

102
00:05:33,080 --> 00:05:34,280
 परीक्षण कोड 

103
00:05:34,280 --> 00:05:38,040
 क्योंकि वे एक ही स्थान पर आपको जो कुछ भी चाहिए उसे डालते हैं, उन्हें एकीकृत विकास कहा जाता है 

104
00:05:38,040 --> 00:05:39,820
 संक्षेप में वातावरण, या आईडीई। 

105
00:05:39,900 --> 00:05:44,420
 सभी आईडीई कोड लिखने के लिए एक टेक्स्ट एडिटर प्रदान करते हैं, अक्सर स्वचालित जैसी उपयोगी सुविधाओं के साथ 

106
00:05:44,420 --> 00:05:46,620
 पठनीयता में सुधार करने के लिए रंग कोडिंग। 

107
00:05:46,629 --> 00:05:50,319
 कई लोग आपके द्वारा टाइप किए जाने वाले वाक्यविन्यास त्रुटियों की जांच भी करते हैं, जैसे कोड के लिए वर्तनी जांच। 

108
00:05:50,319 --> 00:05:54,870
 बड़े कार्यक्रमों में बहुत से व्यक्तिगत स्रोत फ़ाइलें होती हैं, इसलिए आईडीई प्रोग्रामर को व्यवस्थित करने की अनुमति देते हैं 

109
00:05:54,870 --> 00:05:56,640
 और कुशलतापूर्वक सब कुछ नेविगेट करें। 

110
00:05:56,640 --> 00:06:00,700
 आईडीई में भी बनाया गया है कोड को संकलित और चलाने की क्षमता है। 

111
00:06:00,700 --> 00:06:04,310
 और यदि आपका प्रोग्राम दुर्घटनाग्रस्त हो जाता है, क्योंकि यह अभी भी एक काम प्रगति पर है, तो आईडीई ले सकता है 

112
00:06:04,310 --> 00:06:08,229
 आप वापस कोड की रेखा पर जहां यह हुआ, और अक्सर अतिरिक्त जानकारी प्रदान करते हैं 

113
00:06:08,229 --> 00:06:11,800
 आपको बग को ट्रैक करने और ठीक करने में मदद करता है, जो डीबगिंग नामक प्रक्रिया है। 

114
00:06:11,800 --> 00:06:16,159
 यह महत्वपूर्ण है क्योंकि अधिकांश प्रोग्रामर अपने समय परीक्षण के 70 से 80% खर्च करते हैं और 

115
00:06:16,159 --> 00:06:18,090
 डिबगिंग, नया कोड नहीं लिख रहा है। 

116
00:06:18,090 --> 00:06:22,120
 आईडीई में निहित अच्छे उपकरण, प्रोग्रामर को रोकने में मदद करने के लिए एक लंबा सफर तय कर सकते हैं 

117
00:06:22,120 --> 00:06:23,420
 और त्रुटियों को खोजें। 

118
00:06:23,420 --> 00:06:27,600
 कई कंप्यूटर प्रोग्रामर हालांकि उनके आईडीई के प्रति बहुत वफादार हो सकते हैं - लेकिन आइए ईमानदार रहें। 

119
00:06:27,640 --> 00:06:29,080
 वीआईएम वह है जहां यह है। 

120
00:06:29,080 --> 00:06:30,080
 आपको बताएं कि कैसे छोड़ना है। 

121
00:06:30,080 --> 00:06:34,289
 कोडिंग और डिबगिंग के अलावा, प्रोग्रामर के काम का एक और महत्वपूर्ण हिस्सा दस्तावेज है 

122
00:06:34,289 --> 00:06:35,289
 उनका कोड 

123
00:06:35,289 --> 00:06:38,700
 यह "रीड-मी" नामक स्टैंडअलोन फाइलों में किया जा सकता है जो अन्य प्रोग्रामर को बताते हैं 

124
00:06:38,700 --> 00:06:40,750
 डाइविंग से पहले उस मदद फ़ाइल को पढ़ने के लिए। 

125
00:06:40,750 --> 00:06:43,810
 यह टिप्पणियों के साथ कोड में भी सही हो सकता है। 

126
00:06:43,810 --> 00:06:46,919
 ये विशेष रूप से चिह्नित बयान हैं कि प्रोग्राम कोड को अनदेखा करना जानता है 

127
00:06:46,919 --> 00:06:47,919
 संकलित है 

128
00:06:47,919 --> 00:06:51,000
 वे प्रोग्रामर को यह जानने में मदद करने के लिए मौजूद हैं कि स्रोत कोड में क्या है। 

129
00:06:51,000 --> 00:06:54,560
 अच्छा दस्तावेज प्रोग्रामर की मदद करता है जब वे उस कोड पर फिर से जाते हैं जिसे उन्होंने नहीं देखा है 

130
00:06:54,560 --> 00:06:57,849
 थोड़ी देर के लिए, लेकिन यह प्रोग्रामर के लिए भी महत्वपूर्ण है जो पूरी तरह से नए हैं। 

131
00:06:57,849 --> 00:07:02,150
 मैं सिर्फ एक सेकंड लेना चाहता हूं और दोहराता हूं कि जब कोई पैराशूट करता है तो यह सबसे अच्छा होता है 

132
00:07:02,150 --> 00:07:06,400
 आपके गोद में असम्बद्ध और अनियंत्रित कोड का भार, और आपको सचमुच जाना है 

133
00:07:06,400 --> 00:07:08,800
 कोड क्या कर रहा है यह समझने के लिए लाइन से लाइन। 

134
00:07:08,800 --> 00:07:09,580
 गंभीरता से। 

135
00:07:09,580 --> 00:07:10,860
 उस व्यक्ति मत बनो। 

136
00:07:10,860 --> 00:07:13,360
 दस्तावेज़ीकरण कोड पुन: उपयोग को भी बढ़ावा देता है। 

137
00:07:13,380 --> 00:07:16,760
 तो, प्रोग्रामर होने के बजाय लगातार वही चीजें लिखते हैं, वे 

138
00:07:16,761 --> 00:07:19,780
 किसी और के कोड को ट्रैक कर सकते हैं जो उन्हें चाहिए। 

139
00:07:19,780 --> 00:07:23,650
 फिर, दस्तावेज़ीकरण के लिए धन्यवाद, वे इसे बिना किसी कार्यक्रम के अपने कार्यक्रम में काम करने के लिए रख सकते हैं 

140
00:07:23,650 --> 00:07:25,050
 कोड के माध्यम से पढ़ने के लिए। 

141
00:07:25,050 --> 00:07:26,669
 जैसा कि वे कहते हैं, "दस्तावेज़ पढ़ें"। 

142
00:07:26,669 --> 00:07:30,740
 आईडीई के अलावा, सॉफ्टवेयर का एक और महत्वपूर्ण टुकड़ा जो बड़ी टीमों को सहयोगी रूप से काम करने में मदद करता है 

143
00:07:30,740 --> 00:07:36,480
 बड़ी कोडिंग परियोजनाओं पर स्रोत नियंत्रण कहा जाता है, जिसे संस्करण नियंत्रण या संशोधन नियंत्रण भी कहा जाता है। 

144
00:07:36,480 --> 00:07:40,560
 अक्सर, ऐप्पल या माइक्रोसॉफ्ट जैसी बड़ी सॉफ्टवेयर कंपनी में, परियोजनाओं के लिए कोड संग्रहीत किया जाता है 

145
00:07:40,560 --> 00:07:43,310
 केंद्रीकृत सर्वर पर, एक कोड भंडार कहा जाता है। 

146
00:07:43,310 --> 00:07:47,041
 जब कोई प्रोग्रामर कोड के टुकड़े पर काम करना चाहता है, तो वे इसे देख सकते हैं, जैसे 

147
00:07:47,041 --> 00:07:48,669
 एक पुस्तकालय से बाहर एक किताब की जांच। 

148
00:07:48,669 --> 00:07:51,009
 अक्सर, यह एक आईडीई में सही किया जा सकता है। 

149
00:07:51,009 --> 00:07:55,139
 फिर, वे इस कोड को अपने निजी कंप्यूटर पर जो कुछ भी चाहते हैं, उसे संपादित कर सकते हैं, नई सुविधाएं जोड़ सकते हैं 

150
00:07:55,139 --> 00:07:56,639
 और अगर वे काम करते हैं तो परीक्षण। 

151
00:07:56,639 --> 00:08:00,290
 जब प्रोग्रामर को आश्वस्त होता है कि उनके बदलाव काम कर रहे हैं और कोई ढीला सिरों नहीं हैं, तो वे 

152
00:08:00,290 --> 00:08:04,500
 कोड को वापस भंडार में देख सकते हैं, जिसे कोड के रूप में जाना जाता है, हर किसी के लिए 

153
00:08:04,500 --> 00:08:05,500
 उपयोग करने के लिए। 

154
00:08:05,500 --> 00:08:09,379
 जबकि कोड का एक टुकड़ा चेक किया गया है, और संभवतः अद्यतन या संशोधित हो रहा है, अन्य 

155
00:08:09,379 --> 00:08:10,479
 प्रोग्रामर इसे अकेला छोड़ देते हैं। 

156
00:08:10,479 --> 00:08:12,790
 यह अजीब संघर्ष और डुप्लिकेट काम से बचाता है। 

157
00:08:12,790 --> 00:08:17,159
 इस तरह, सैकड़ों प्रोग्रामर एक साथ टुकड़ों में और बाहर जांच कर सकते हैं 

158
00:08:17,159 --> 00:08:19,949
 कोड के, बड़े पैमाने पर विशाल प्रणाली का निर्माण। 

159
00:08:19,949 --> 00:08:23,800
 गंभीरता से, आप नहीं चाहते कि कोई बग्गी कोड कर रहा हो, क्योंकि अन्य लोग और टीम 

160
00:08:23,800 --> 00:08:25,169
 इस पर भरोसा कर सकते हैं। 

161
00:08:25,169 --> 00:08:27,949
 उनका कोड दुर्घटनाग्रस्त हो गया और भ्रम पैदा हो गया। 

162
00:08:27,949 --> 00:08:31,439
 सर्वर पर संग्रहीत कोड का मास्टर संस्करण हमेशा बिना संकलित होना चाहिए 

163
00:08:31,440 --> 00:08:33,010
 त्रुटियों और न्यूनतम बग के साथ चलाने के लिए। 

164
00:08:33,010 --> 00:08:34,720
 लेकिन कभी-कभी बग रेंगते हैं। 

165
00:08:34,720 --> 00:08:38,460
 सौभाग्य से, स्रोत नियंत्रण सॉफ्टवेयर सभी परिवर्तनों का ट्रैक रखता है, और यदि कोई बग पाया जाता है, 

166
00:08:38,470 --> 00:08:42,409
 पूरा कोड, या सिर्फ एक टुकड़ा, पहले, स्थिर संस्करण पर वापस लाया जा सकता है। 

167
00:08:42,409 --> 00:08:47,700
 यह भी ट्रैक करता है कि प्रत्येक परिवर्तन किसने किया है, इसलिए सहकर्मी बुरा भेज सकते हैं, मेरा मतलब है, सहायक 

168
00:08:47,700 --> 00:08:50,220
 और अपमानजनक व्यक्ति को ईमेल को प्रोत्साहित करना। 

169
00:08:50,220 --> 00:08:54,120
 डिबगिंग लेखन कोड के साथ हाथ में है, और यह अक्सर एक व्यक्ति द्वारा किया जाता है 

170
00:08:54,120 --> 00:08:55,290
 या छोटी टीम। 

171
00:08:55,290 --> 00:08:59,030
 डिबगिंग का बड़ा चित्र संस्करण गुणवत्ता आश्वासन परीक्षण, या क्यूए है। 

172
00:08:59,030 --> 00:09:02,480
 यह वह जगह है जहां एक टीम कठोर रूप से सॉफ़्टवेयर के एक टुकड़े का परीक्षण करती है, जो बनाने का प्रयास करती है 

173
00:09:02,480 --> 00:09:04,580
 अप्रत्याशित परिस्थितियां जो इसे यात्रा कर सकती हैं। 

174
00:09:04,580 --> 00:09:06,440
 असल में, वे बग प्राप्त करते हैं। 

175
00:09:06,450 --> 00:09:10,740
 सभी झुर्रियों को प्राप्त करना एक बड़ा प्रयास है, लेकिन यह सुनिश्चित करने में महत्वपूर्ण है कि सॉफ़्टवेयर काम करता है 

176
00:09:10,740 --> 00:09:15,760
 जहाजों के सामने कल्पना करने योग्य कई स्थितियों में जितने उपयोगकर्ताओं के लिए इरादा है। 

177
00:09:15,760 --> 00:09:19,970
 आपने शायद बीटा सॉफ्टवेयर के बारे में सुना है यह सॉफ्टवेयर का एक संस्करण है जो ज्यादातर पूरा हो गया है, 

178
00:09:19,970 --> 00:09:21,720
 लेकिन 100% पूरी तरह से परीक्षण नहीं किया। 

179
00:09:21,720 --> 00:09:25,660
 कंपनियां कभी-कभी बीटा संस्करणों को जनता को मुद्दों की पहचान करने में मदद करने के लिए जारी करती हैं, 

180
00:09:25,660 --> 00:09:28,440
 यह अनिवार्य रूप से एक मुफ्त क्यूए टीम प्राप्त करने की तरह है। 

181
00:09:28,440 --> 00:09:33,220
 बीटा से पहले जो संस्करण आता है वह उतना ही नहीं है: अल्फा संस्करण। 

182
00:09:33,320 --> 00:09:36,140
 यह आमतौर पर इतना मोटा और छोटी गाड़ी है, यह केवल आंतरिक रूप से परीक्षण किया जाता है। 

183
00:09:36,140 --> 00:09:39,860
 तो, यह उपकरण, चाल और तकनीक के संदर्भ में हिमशैल की नोक है जो अनुमति देता है 

184
00:09:39,860 --> 00:09:44,750
 सॉफ़्टवेयर इंजीनियरों को सॉफ़्टवेयर के विशाल टुकड़े बनाने के लिए जो आज हम जानते हैं और प्यार करते हैं 

185
00:09:44,750 --> 00:09:47,600
 यूट्यूब, ग्रैंड थेफ्ट ऑटो 5, और पावरपॉइंट। 

186
00:09:47,600 --> 00:09:50,940
 जैसा कि आप उम्मीद कर सकते हैं, कोड की उन लाखों लाइनों को कुछ गंभीर प्रसंस्करण की आवश्यकता है 

187
00:09:50,940 --> 00:09:56,880
 उपयोगी गति पर चलाने की शक्ति, इसलिए अगला एपिसोड हम इस बारे में बात करेंगे कि कंप्यूटर्स इतने अविश्वसनीय रूप से कैसे पहुंचे। 

188
00:09:56,920 --> 00:00:00,000
 तब आप देखना। 

